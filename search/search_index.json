{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to mini-platform 's home, I will document my learning experience building a platform a Platform on top of Kubernetes focusing on developer experience. I got as inspiration the workshop created by @salaboy called From Monolith to Kubernetes and this very cool presentation on State of Open Con 23 . Platform on MeLi Today, I am a Software Enginner at Mercado Livre (MeLi) and I am responsible for creating toolings for developers, such as Documentation Platform and Performance Test Platform. Working on MeLi, when I want to create an application (service, microservice, etc.), I just tell to Fury (interface web) to create for me, and after seconds I have a Git repository, dashboards for Observability, etc. I as developer wants a way to easily get a Github repository Motivation: Nowadays many companies want to deliver their features faster and faster. In the context of microservices in a big company, almost every day more than one microservice appears, and this microservice is initially a git repository. The developer needs to get a repo in an easy way. Thoughts I thought to create a web interface with NextJS or just React, but as I still have problems with overengineering, I was going to try to make the frontend as beautiful as possible. So decides to create a CLI that does this for me. I decided to create a command line interface (CLI) with the project cobra . Proposal: The proposal here is to create a command line interface to allow the developer to create a git repository. This CLI will be called minictl . The minictl repository can be found here and the step-by-step for creating it is here . Thank you so much!","title":"Welcome"},{"location":"#welcome","text":"Welcome to mini-platform 's home, I will document my learning experience building a platform a Platform on top of Kubernetes focusing on developer experience. I got as inspiration the workshop created by @salaboy called From Monolith to Kubernetes and this very cool presentation on State of Open Con 23 .","title":"Welcome"},{"location":"#platform-on-meli","text":"Today, I am a Software Enginner at Mercado Livre (MeLi) and I am responsible for creating toolings for developers, such as Documentation Platform and Performance Test Platform. Working on MeLi, when I want to create an application (service, microservice, etc.), I just tell to Fury (interface web) to create for me, and after seconds I have a Git repository, dashboards for Observability, etc.","title":"Platform on MeLi"},{"location":"#i-as-developer-wants-a-way-to-easily-get-a-github-repository","text":"Motivation: Nowadays many companies want to deliver their features faster and faster. In the context of microservices in a big company, almost every day more than one microservice appears, and this microservice is initially a git repository. The developer needs to get a repo in an easy way. Thoughts I thought to create a web interface with NextJS or just React, but as I still have problems with overengineering, I was going to try to make the frontend as beautiful as possible. So decides to create a CLI that does this for me. I decided to create a command line interface (CLI) with the project cobra . Proposal: The proposal here is to create a command line interface to allow the developer to create a git repository. This CLI will be called minictl . The minictl repository can be found here and the step-by-step for creating it is here . Thank you so much!","title":"I as developer wants a way to easily get a Github repository"},{"location":"CLI/creating-github-repository/","text":"Introduction Creating Github Organization We will use an Org to simulate a real world (or aproximatelly one). You can see how to create a new organization on Github here Using go-github In this page I created the command minictl create application --name and now I will use the go-github project to create our repository. Personal Access Token To get access to Github, was necessary to create a Personal Access Token on Github. To get the Personal Access Token, you need to follow this official Github tutorial . Is necessary to select those scopes to get access to create an repository: Code to create the repo I created a minimal code to create the repository, is required to configure two environment variables, the first one is MINI_PLATFORM_ORG and the second one is MINI_PLATFORM_GH_TOKEN . MINI_PLATFORM_ORG is the organization's name. MINI_PLATFORM_GH_TOKEN is your Personal Access Token. package repo import ( \"context\" \"fmt\" \"github.com/google/go-github/v52/github\" \"golang.org/x/oauth2\" \"log\" \"os\" ) type Repo interface { Create ( name string ) } type repo struct { Client * github . Client } func ( r * repo ) Create ( name string ) { ctx := context . Background () org := os . Getenv ( \"MINI_PLATFORM_ORG\" ) repository , response , err := r . Client . Repositories . Create ( ctx , org , & github . Repository { Name : & name , }) if err != nil { log . Fatalln ( \"error while creating repository\" , err . Error ()) } if response . StatusCode == 201 { log . Println ( fmt . Sprintf ( ` Hey! Your repository is ready Get the repository: git clone %s` , * repository . CloneURL )) } else { log . Fatalln ( \"Sorry! was not to possible creating your repository\" ) } } func NewRepo () Repo { personalAccessToken := os . Getenv ( \"MINI_PLATFORM_GH_TOKEN\" ) ctx := context . Background () ts := oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : personalAccessToken }) tc := oauth2 . NewClient ( ctx , ts ) client := github . NewClient ( tc ) return & repo { Client : client , } } After this implementation, was necessary to execute it when minictl create application --name is called: func NewCreateApplicationCommand () * cobra . Command { var createApplicationCmd = & cobra . Command { Use : \"application\" , Run : func ( cmd * cobra . Command , args [] string ) { log . Println ( fmt . Sprintf ( \"Creating application with name '%s'\" , applicationName )) newRepo := repo . NewRepo () newRepo . Create ( applicationName ) }, } createApplicationCmd . PersistentFlags (). StringVar ( & applicationName , \"name\" , \"\" , \"--name=application-name\" ) _ = createApplicationCmd . MarkPersistentFlagRequired ( \"name\" ) return createApplicationCmd } Using the minictl It will be a step-by-step to create a repository with minictl . Clone the repository: git clone https://github.com/mcruzdev/minictl ` Build the CLI: cd minictl && go build -o = minictl . Set all required variables MINI_PLATFORM_ORG and MINI_PLATFORM_GH_TOKEN and execute the CLI: ./minictl create application --name = mini-platform-api The output shoul looks like it: 2023/05/13 11:05:21 Creating application with name 'team-api' 2023/05/13 11:05:22 Hey! Your repository is ready Get the repository: git clone https://github.com/mini-platform/team-api.git There is no validation yet, but if you create a valid repository name, it works well! Contribute If you want to collabare with me, create an issue and open a pull request here . The commit related with this page is here .","title":"Introduction"},{"location":"CLI/creating-github-repository/#introduction","text":"","title":"Introduction"},{"location":"CLI/creating-github-repository/#creating-github-organization","text":"We will use an Org to simulate a real world (or aproximatelly one). You can see how to create a new organization on Github here","title":"Creating Github Organization"},{"location":"CLI/creating-github-repository/#using-go-github","text":"In this page I created the command minictl create application --name and now I will use the go-github project to create our repository.","title":"Using go-github"},{"location":"CLI/creating-github-repository/#personal-access-token","text":"To get access to Github, was necessary to create a Personal Access Token on Github. To get the Personal Access Token, you need to follow this official Github tutorial . Is necessary to select those scopes to get access to create an repository:","title":"Personal Access Token"},{"location":"CLI/creating-github-repository/#code-to-create-the-repo","text":"I created a minimal code to create the repository, is required to configure two environment variables, the first one is MINI_PLATFORM_ORG and the second one is MINI_PLATFORM_GH_TOKEN . MINI_PLATFORM_ORG is the organization's name. MINI_PLATFORM_GH_TOKEN is your Personal Access Token. package repo import ( \"context\" \"fmt\" \"github.com/google/go-github/v52/github\" \"golang.org/x/oauth2\" \"log\" \"os\" ) type Repo interface { Create ( name string ) } type repo struct { Client * github . Client } func ( r * repo ) Create ( name string ) { ctx := context . Background () org := os . Getenv ( \"MINI_PLATFORM_ORG\" ) repository , response , err := r . Client . Repositories . Create ( ctx , org , & github . Repository { Name : & name , }) if err != nil { log . Fatalln ( \"error while creating repository\" , err . Error ()) } if response . StatusCode == 201 { log . Println ( fmt . Sprintf ( ` Hey! Your repository is ready Get the repository: git clone %s` , * repository . CloneURL )) } else { log . Fatalln ( \"Sorry! was not to possible creating your repository\" ) } } func NewRepo () Repo { personalAccessToken := os . Getenv ( \"MINI_PLATFORM_GH_TOKEN\" ) ctx := context . Background () ts := oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : personalAccessToken }) tc := oauth2 . NewClient ( ctx , ts ) client := github . NewClient ( tc ) return & repo { Client : client , } } After this implementation, was necessary to execute it when minictl create application --name is called: func NewCreateApplicationCommand () * cobra . Command { var createApplicationCmd = & cobra . Command { Use : \"application\" , Run : func ( cmd * cobra . Command , args [] string ) { log . Println ( fmt . Sprintf ( \"Creating application with name '%s'\" , applicationName )) newRepo := repo . NewRepo () newRepo . Create ( applicationName ) }, } createApplicationCmd . PersistentFlags (). StringVar ( & applicationName , \"name\" , \"\" , \"--name=application-name\" ) _ = createApplicationCmd . MarkPersistentFlagRequired ( \"name\" ) return createApplicationCmd }","title":"Code to create the repo"},{"location":"CLI/creating-github-repository/#using-the-minictl","text":"It will be a step-by-step to create a repository with minictl . Clone the repository: git clone https://github.com/mcruzdev/minictl ` Build the CLI: cd minictl && go build -o = minictl . Set all required variables MINI_PLATFORM_ORG and MINI_PLATFORM_GH_TOKEN and execute the CLI: ./minictl create application --name = mini-platform-api The output shoul looks like it: 2023/05/13 11:05:21 Creating application with name 'team-api' 2023/05/13 11:05:22 Hey! Your repository is ready Get the repository: git clone https://github.com/mini-platform/team-api.git There is no validation yet, but if you create a valid repository name, it works well!","title":"Using the minictl"},{"location":"CLI/creating-github-repository/#contribute","text":"If you want to collabare with me, create an issue and open a pull request here . The commit related with this page is here .","title":"Contribute"},{"location":"CLI/creating-minictl/","text":"Hello minictl Before you begin Before all, you need to install: GoLang version 1.20.4 Creating the project Let's start, create the folder to be the minictl home: mkdir minictl && cd minictl Init the project with GoLang tooling: go mod init com.github.mcruzdev.miniplatform.minictl Creating the root command Install cobra module: go get -u github.com/spf13/cobra@latest Let's to create the main.go file: The following file will be our entrypoint: // main.go package main import ( \"com.github.mcruzdev.miniplatform.minictl/cmd/minictl\" ) func main () { minictl . Execute () } Let's to create the main command (root): // cmd/minictl/minictl.go package minictl import ( \"fmt\" \"github.com/spf13/cobra\" ) var rootCmd = & cobra . Command { Use : \"minictl\" , Run : func ( cmd * cobra . Command , args [] string ) { fmt . Println ( \"Running inside minictl\" ) }, } func Execute () { rootCmd . Execute () } To build and execute the CLI, do: go build main.go ./main.go The output should look like: Running inside minictl Creating the create application command To organize our CLI project, let's create a page for create command: Inside the root directory, run the following command: mkdir create && touch create/create.go && touch create/application.go First, we will create the command for command create , we can have some sub-commands. // create/create.go package create import ( \"fmt\" \"github.com/spf13/cobra\" ) // CommandCreate handles minictl create command. func CommandCreate () * cobra . Command { var createCmd = & cobra . Command { Use : \"create\" , Run : func ( cmd * cobra . Command , args [] string ) { fmt . Println ( \"Running create command\" ) }, } createCmd . AddCommand ( CommandCreateApplication ()) return createCmd } On create/application.go we will handle the command minictl create application --name=minictl-api command. // create/application.go package create import ( \"fmt\" \"github.com/spf13/cobra\" \"log\" ) var applicationName string func CommandCreateApplication () * cobra . Command { var createApplicationCmd = & cobra . Command { Use : \"application\" , Run : func ( cmd * cobra . Command , args [] string ) { log . Println ( fmt . Sprintf ( \"Creating application with name '%s'\" , applicationName )) }, } createApplicationCmd . PersistentFlags (). StringVar ( & applicationName , \"name\" , \"\" , \"--name=application-name\" ) _ = createApplicationCmd . MarkPersistentFlagRequired ( \"name\" ) return createApplicationCmd } Build the CLI and run again with ./main create application --name=my-application to see the output. The output should looks like it: 2023 /05/11 21 :34:17 Creating application with name 'my-application'","title":"Hello minictl"},{"location":"CLI/creating-minictl/#hello-minictl","text":"","title":"Hello minictl"},{"location":"CLI/creating-minictl/#before-you-begin","text":"Before all, you need to install: GoLang version 1.20.4","title":"Before you begin"},{"location":"CLI/creating-minictl/#creating-the-project","text":"Let's start, create the folder to be the minictl home: mkdir minictl && cd minictl Init the project with GoLang tooling: go mod init com.github.mcruzdev.miniplatform.minictl","title":"Creating the project"},{"location":"CLI/creating-minictl/#creating-the-root-command","text":"Install cobra module: go get -u github.com/spf13/cobra@latest Let's to create the main.go file: The following file will be our entrypoint: // main.go package main import ( \"com.github.mcruzdev.miniplatform.minictl/cmd/minictl\" ) func main () { minictl . Execute () } Let's to create the main command (root): // cmd/minictl/minictl.go package minictl import ( \"fmt\" \"github.com/spf13/cobra\" ) var rootCmd = & cobra . Command { Use : \"minictl\" , Run : func ( cmd * cobra . Command , args [] string ) { fmt . Println ( \"Running inside minictl\" ) }, } func Execute () { rootCmd . Execute () } To build and execute the CLI, do: go build main.go ./main.go The output should look like: Running inside minictl","title":"Creating the root command"},{"location":"CLI/creating-minictl/#creating-the-create-application-command","text":"To organize our CLI project, let's create a page for create command: Inside the root directory, run the following command: mkdir create && touch create/create.go && touch create/application.go First, we will create the command for command create , we can have some sub-commands. // create/create.go package create import ( \"fmt\" \"github.com/spf13/cobra\" ) // CommandCreate handles minictl create command. func CommandCreate () * cobra . Command { var createCmd = & cobra . Command { Use : \"create\" , Run : func ( cmd * cobra . Command , args [] string ) { fmt . Println ( \"Running create command\" ) }, } createCmd . AddCommand ( CommandCreateApplication ()) return createCmd } On create/application.go we will handle the command minictl create application --name=minictl-api command. // create/application.go package create import ( \"fmt\" \"github.com/spf13/cobra\" \"log\" ) var applicationName string func CommandCreateApplication () * cobra . Command { var createApplicationCmd = & cobra . Command { Use : \"application\" , Run : func ( cmd * cobra . Command , args [] string ) { log . Println ( fmt . Sprintf ( \"Creating application with name '%s'\" , applicationName )) }, } createApplicationCmd . PersistentFlags (). StringVar ( & applicationName , \"name\" , \"\" , \"--name=application-name\" ) _ = createApplicationCmd . MarkPersistentFlagRequired ( \"name\" ) return createApplicationCmd } Build the CLI and run again with ./main create application --name=my-application to see the output. The output should looks like it: 2023 /05/11 21 :34:17 Creating application with name 'my-application'","title":"Creating the create application command"}]}